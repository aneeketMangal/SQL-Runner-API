/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package assignment_1;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.Connection;
import java.util.List;

import assignment_1.exceptions.DatabaseNotConnectedException;
import assignment_1.exceptions.ParamTypeDifferentException;
import assignment_1.interfaces.SqlRunner;
import assignment_1.model.QueryObject;
import assignment_1.service.XMLParser;

public class Library implements SqlRunner {

    public Connection connection;
    public String xmlFilePath;
    public XMLParser xmlParser;

    // Constructor for library Object
    public Library(Connection connection, String filePath){
        this.connection = connection;
        this.xmlFilePath = filePath;
    }

    // Method to check if the connection object is present
    public void checkConnection() {
        if (connection == null) {
            throw new DatabaseNotConnectedException("Database not connected");
        }
    }

    public static void main(){
        new Library(null, "dfsa").checkConnection();
    }
    
    public <T> void checkParamTypes(QueryObject qObj, T queryParam) {
        String paramType = queryParam.getClass().getName();
        String paramTypeInXML = qObj.paramType;
        if (!paramType.equals(paramTypeInXML)) {
            throw new ParamTypeDifferentException(paramType, paramType, qObj.id);
        }
    }

    public <T> String populateQuery(QueryObject qObj, T queryParam){
        this.checkParamTypes(qObj, queryParam);
       
        String populatedQuery = qObj.query;
        Field [] fields = queryParam.getClass().getDeclaredFields();
        for(Field field: fields){
            String fieldName = field.getName();
            String fieldValue = null;
            try {
                fieldValue = (String) field.get(queryParam);
                populatedQuery = populatedQuery.replaceAll("\\${"+fieldName+"\\}", fieldValue);
            } catch (IllegalArgumentException | IllegalAccessException e) {
                e.printStackTrace();
            }
        }
        return populatedQuery;
    }


    @Override
    public <T, R> R selectOne(String queryId, T queryParam, Class<R> resultType) {
        // TODO: Implement this method
        return null;
    }

    @Override
    public <T, R> List<R> selectMany(String queryId, T queryParam, Class<R> resultType){
        
        // TODO Auto-generated method stub
        return null;
    }
    
    @Override
    public <T> int insert(String queryId, T queryParam){
        this.checkConnection();
        QueryObject queryObject = this.xmlParser.getQueryObject(queryId);
        
        try {
            Class<?> classType = queryParam.getClass();
            Object temp;
            temp = classType.getConstructor().newInstance();
            if(((Class<?>) temp).isInstance(classType)){
                System.out.println("yes");
            }
            return 1;
        } catch (
            InstantiationException | 
            IllegalAccessException | 
            IllegalArgumentException | 
            InvocationTargetException | 
            NoSuchMethodException | 
            SecurityException e
        ) {
            e.printStackTrace();
        }
        return 0;        
    }

    @Override
    public <T> int delete(String queryId, T queryParam) {
        // TODO Auto-generated method stub
        return 0;
    }

    @Override
    public <T> int update(String queryId, T queryParam) {
        // TODO Auto-generated method stub
        return 0;
    }
}
